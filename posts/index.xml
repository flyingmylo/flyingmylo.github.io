<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - Mylo</title>
        <link>http://flyingmylo.com/posts/</link>
        <description>所有文章 | Mylo</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 20 Dec 2022 17:03:14 &#43;0800</lastBuildDate><atom:link href="http://flyingmylo.com/posts/" rel="self" type="application/rss+xml" /><item>
    <title>git 文件夹瘦身</title>
    <link>http://flyingmylo.com/posts/git-slim/</link>
    <pubDate>Tue, 20 Dec 2022 17:03:14 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/git-slim/</guid>
    <description><![CDATA[git 版本库提交过多，导致项目根目录下的 .git 文件夹体积巨大，原因可能不只是单纯的提交历史过多，根本原因是历史提交中包含有对大文件的引用，即使现在的项目中已经不存在这些文件了，但其引用关联依旧会被 git 保留下来。
找到项目根目录下的 .idx 文件：.git/objects/pack/pack-************.idx
踩坑方案 git filter-branch 识别出最大的三个文件 git verify-pack -v .git/objects/pack/pack-*********.idx | sort -k 3 -n | tail -3
运行结果如下👇
81f0aa7f9298ae04dbb3c48d8e371295dd81c513 blob 5680214 1376617 73325123 77e75e8630d3ae2338ee11b04f3b1ce5f1d80c2f blob 5698996 1376836 115744091 3e9a2ee73bea2c4bdfe7ef98c9d2f78353b8eedb blob 5698998 1376837 61415784 查询大文件 执行：
git rev-list --objects --all | grep -f &lt;(git verify-pack -v .git/objects/pack/******.idx| sort -k 3 -n | cut -f 1 -d &quot; &quot; | tail -10)
路径及文件名结果如下👇
"]]></description>
</item>
<item>
    <title>2022 08 02 Hejimoshi</title>
    <link>http://flyingmylo.com/posts/hejimoshi/</link>
    <pubDate>Tue, 02 Aug 2022 08:14:31 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/hejimoshi/</guid>
    <description><![CDATA[]]></description>
</item>
<item>
    <title>Git 常用命令</title>
    <link>http://flyingmylo.com/posts/git-command/</link>
    <pubDate>Mon, 18 Jul 2022 15:30:06 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/git-command/</guid>
    <description><![CDATA[分支操作 新建本地分支并切换到新分支
git checkout -b feat/dev 本地分支推送到远程
git push origin feat/dev:feat/dev 设置跟踪
git branch --set-upstream-to=origin/dev dev 删除本地分支
git branch -d dev 如果一个分支还没有被推送或合并，强制删除使用 -D
git branch -D dev 删除远程分支
git push origin --delete &lt;branch&gt; 或 git push origin :&lt;branch&gt; ]]></description>
</item>
<item>
    <title>面经（2022春）</title>
    <link>http://flyingmylo.com/posts/interview/</link>
    <pubDate>Wed, 13 Jul 2022 21:27:03 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/interview/</guid>
    <description><![CDATA[vue 相关  mixin 相关场景以及利弊，拥有多个属性时的执行顺序， v-model 原理，在下拉选择器组件中是怎么实现的 filter 怎么实现，使用场景 插槽的实现原理，如何传值 v-for 中 key 的作用，延伸到 diff 实现，不同位置的比较 vnode 概念 v-if 控制 dom 显隐时， vdom 是如何处理的 watch 监听是的 deep: true 实现原理 nextTick 原理 computed 和 watch 的区别 Vue.use 和 Vue.install Vue 中手动 extend data 中的属性是定义在 MVVM 中的哪个环节  css 相关  回流和重绘的概念，绝对定位是否会导致回流 flex: 1 的分别代表什么属性以及作用 伪元素和伪类的区别，分别有哪些 visibility: hidden 和 opacity 是否触发点击事件  js 相关  let/const/var 区别，用 const 声明对象时，是否可以改变对象的属性值，为什么 深度优先搜索和广度优先搜索 如何证明 js 对象里存在循环引用 类型判断的方法，typeof 对象的类属性 实例对象是否是 Function ，instanceof Function 结果 promise 执行顺序，事件循环 es5 模拟 class 的实现 localStorage 如何实现过期时间 手机号正则  工程化相关  介绍 webpack 常用的配置以及功能 webpack 多页面有多个入口时如何配置 source-map 分类，如何配置和调试 webpack 中怎么隔离 css 性能优化方案，代码/打包/资源加载方面 热更新原理  概念类问题  http/https 区别 介绍 options 请求的意义 MVVM/MVC 的区别，如何实现一个 MVVM 简述 XSS 和 CSRF 的概念，并列举几种安全防范策略  编程题  编写一个函数，大小写字母取反  const fn = (string) =&gt; { let ans = &#39;&#39; for (let v of string) { ans += v.]]></description>
</item>
<item>
    <title>算法之 BFS 与 DFS</title>
    <link>http://flyingmylo.com/posts/dfs-bfs/</link>
    <pubDate>Thu, 07 Jul 2022 21:27:33 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/dfs-bfs/</guid>
    <description><![CDATA[深度优先搜索 DFS 深度优先搜索（Depth-First-Search），是一种用来遍历或者搜索树或图这种数据结构的算法，以树为例，其搜索过程会从根节点出发，尽可能深地遍历每个子节点，而且每个节点只能访问一次。
深度优先搜索是一个不断回溯的过程，以二叉树的先序遍历为例：
const preorderTraversal = function (root) { const ans = [] const dfs = (node, ans) =&gt; { if (node === null) return ans.push(node.val) dfs(node.left, ans) dfs(node.right, ans) } dfs(root, ans) return ans } const obj = { x: 1, a: 1, b: 2, c: 3, d: { e: 4, f: 5, }, } const isObject = (obj) =&gt; { return obj &amp;&amp; Object.prototype.toString.call(obj) === &#34;[object Object]&#34; } // 深度优先搜索获取对象的所有键 function dfs(obj, keys = []) { Object.]]></description>
</item>
<item>
    <title>原型</title>
    <link>http://flyingmylo.com/posts/prototype/</link>
    <pubDate>Fri, 10 Jun 2022 12:44:17 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/prototype/</guid>
    <description><![CDATA[function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; } function SubType() { this.subproperty = false; } // 修改 SubType 的原型，重新指向 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; } let instance = new SubType(); console.log(instance.getSuperValue()) // true console.log(instance.getSubValue()) // false  原型链" 原型链]]></description>
</item>
<item>
    <title>「译」深入了解现代网络浏览器（1/4）</title>
    <link>http://flyingmylo.com/posts/inside-look-at-modern-web-browser-1/</link>
    <pubDate>Wed, 18 May 2022 23:40:32 &#43;0800</pubDate>
    <author>xxxx</author>
    <guid>http://flyingmylo.com/posts/inside-look-at-modern-web-browser-1/</guid>
    <description><![CDATA[📌 本篇原文发表于 2018.09.05，正文中出现的有关于时间概念的语句，阅读时请注意切换语境。 👉🏻原文链接
 中央处理器/图形处理器/内存/多进程架构 在这个包含 4 篇文章的博客系列中，我们将从高阶架构到具体的渲染细节来深入 Chrome 浏览器内部了解其是怎么运作的。如果你曾经好奇浏览器是怎么把代码转变成一个功能齐备的网站，或者你并不确定为什么一个具体的技术细节能够带来性能提升，那么这个系列正好是为你准备的。
作为系列第一篇，我们将会了解一些核心的计算机术语和 Chrome 浏览器的多进程架构。如果你对 CPU/GPU 和 进程/线程已经很熟悉，可以直接跳到 浏览器架构 章节。
计算机的核心 - CPU 和 GPU  为了理解浏览器所运行的环境，我们需要先了解计算机的一些部件以及它们是做什么的。
 中央处理器 CPU 首先是中央处理器（CPU, Central Processing Unit）。CPU 可以被看作是一台计算机的大脑，一个 CPU 内核可以想象成一位办公室工作人员，能够处理一个接一个被安排的多个任务，可以处理一切从数学甚至到艺术领域的难题，而且它知道如何去响应一个用户的指令。以前的大多数 CPU 都是单个芯片，一个内核就相当于是一个 CPU 被嵌入到一个芯片上。在现代的硬件条件下，出现了多核处理器，也赋予了手机、笔记本更强的计算能力。
图 1：四个 CPU 内核就像彼此相邻的办公室职员一样处理多个任务" 图 1：四个 CPU 内核就像彼此相邻的办公室职员一样处理多个任务 
图形处理器 GPU 图形处理器是计算机里的另一个部件。和 CPU 不同的是，GPU 更擅长在多核之间处理一些简单的任务。顾名思义，GPU 最初是被开发成处理图形任务的模块，这也是为什么在很多图形计算的背景下，会把“使用 GPU”或“支持 GPU”和快速渲染、流畅的交互体验相关联在一起。近些年来，有了 GPU 加速的计算能力，也使 GPU 独立承载越来越多的计算成为可能。
图2：多个带着扳手🔧️的 GPU 内核，表明它们只能处理有限的任务" 图2：多个带着扳手🔧️的 GPU 内核，表明它们只能处理有限的任务]]></description>
</item>
</channel>
</rss>
