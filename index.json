[{"categories":null,"content":"Git 版本仓库提交过多，会导致项目根目录下的 .git 文件夹体积巨大，原因可能不只是单纯的提交历史过多，而是历史提交中包含有对大文件的引用，即使现在的项目中已经不存在这些文件了，但其引用关联依旧会被 git 保留下来。 ","date":"2022-12-20","objectID":"/posts/git-slim/:0:0","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"踩坑方案一 git filter-branch 命令可以改写历史中大量的提交，但是它有很多陷阱，而且官方文档中已经不推荐使用它来重写历史了，当然，这个坑是我踩过之后才知道的。 ","date":"2022-12-20","objectID":"/posts/git-slim/:1:0","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"识别查询大文件 找到项目根目录下的 .idx 文件，路径： .git/objects/pack/pack-************.idx 执行： git rev-list --objects --all | grep -f \u003c(git verify-pack -v .git/objects/pack/******.idx| sort -k 3 -n | cut -f 1 -d \" \" | tail -10) 运行结果大致如下： c0b33abdf3af4f0a4ae82d6243954eeb344432d9 src/components/Emoji/emoji.png a08b3b0f766d26729cbaf0b7e86212b0ca4a5569 dist/js/2a10361c.async.js 1d26f0da81c885c676badb026367a47183013fb5 dist/js/84ad94bf.async.js eb07071cdea7e019953a3a6778a4bb6e728ea13d dist/js/4922a65f.async.js 7ddf057a0e26f300137c84cf03dbe088a69da488 dist/js/62f9d99c.async.js ","date":"2022-12-20","objectID":"/posts/git-slim/:1:1","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"删除文件 将该文件从历史记录的所有 tree 中移除，执行： git filter-branch --index-filter 'git rm --cached --ignore-unmatch src/components/Emoji/emoji.png' 注：需要依次执行该命令去删除这些大文件，可能会有很多 jpg/js.map/gif 等类型的文件。 ","date":"2022-12-20","objectID":"/posts/git-slim/:1:2","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"推送到远程 rm -rf .git/refs/original/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now git push --force 依次执行完以上命令后，此时去检查远程仓库，结果令人诧异，居然…没有…生效…本地确实是清理掉了一部分空间，从 1.2G 瘦身到 600M 左右，但是推送后并没有作用，于是继续寻找其他方案，结果看到 stackoverflow 上有一个一摸一样的问题，按 Date modified (newest first) 排序之后，看到👇 \" 也就是说 2022 了，git filter-branch 已经不好使了，推送到远程之后没有任何作用，方案一以失败告状。 ","date":"2022-12-20","objectID":"/posts/git-slim/:1:3","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"终极方案二 git 官方文档推荐了这个库： git-filter-pro ，它是一个可以重写 git 历史的多功能 Python 脚本，即使现在在项目当中找不到那些历史文件，它依然可以找到它们并进行清理（看来这才是我想要的东西）。 ","date":"2022-12-20","objectID":"/posts/git-slim/:2:0","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"安装 brew install git-filter-repo ❌ 报错 No such file or directory @ rb_sysopen -xxxxx ✅ 解决方案 原因是使用国内镜像但是该镜像未完全同步的问题，临时去除镜像即可： export HOMEBREW_BOTTLE_DOMAIN='' ","date":"2022-12-20","objectID":"/posts/git-slim/:2:1","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"使用 这里可以搭配此命令来找到那些历史中的大文件，然后逐一清理。 git rev-list --objects --all | grep -f \u003c(git verify-pack -v .git/objects/pack/******.idx| sort -k 3 -n | cut -f 1 -d \" \" | tail -10) 假设要清理全部的 *.jpg 文件，只需要如下命令，需要注意的是这样也会把项目中现有的所有 .jpg 文件清理掉。 git filter-repo --path-glob '*.jpg' --invert-paths 之后，强制推送到远程👇 git push --all --force git push --tags --force 废了一些功夫，效果一级棒👍 清理前\" 清理前 清理后\" 清理后 参考链接： Git-工具-重写历史 git-filter-repo ","date":"2022-12-20","objectID":"/posts/git-slim/:2:2","tags":["Git"],"title":"git 文件夹瘦身","uri":"/posts/git-slim/"},{"categories":null,"content":"新建本地分支并切换到新分支 git checkout -b feat/abc 本地分支推送到远程（x） git push origin feat/abc:feat/abc 设置跟踪（y） git branch --set-upstream-to=origin/feat/abc feat/abc 举例：如果想要把新建的 abc 本地分支推送到远程并建立跟踪，需要使用以上 x 和 y 两条命令，也可以使用以下一条命令： git push -u origin feat/abc 删除本地分支 git branch -d abc 如果一个分支还没有被推送或合并，强制删除使用 -D git branch -D abc 删除远程分支 git push origin --delete abc 或 git push origin :abc ","date":"2022-07-18","objectID":"/posts/git-command/:0:0","tags":[""],"title":"Git 常用命令","uri":"/posts/git-command/"},{"categories":null,"content":"vue 相关 mixin 相关场景以及利弊，拥有多个属性时的执行顺序， v-model 原理，在下拉选择器组件中是怎么实现的 filter 怎么实现，使用场景 插槽的实现原理，如何传值 v-for 中 key 的作用，延伸到 diff 实现，不同位置的比较 vnode 概念 v-if 控制 dom 显隐时， vdom 是如何处理的 watch 监听是的 deep: true 实现原理 nextTick 原理 computed 和 watch 的区别 Vue.use 和 Vue.install Vue 中手动 extend data 中的属性是定义在 MVVM 中的哪个环节 ","date":"2022-07-13","objectID":"/posts/interview/:0:1","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"css 相关 回流和重绘的概念，绝对定位是否会导致回流 flex: 1 的分别代表什么属性以及作用 伪元素和伪类的区别，分别有哪些 visibility: hidden 和 opacity 是否触发点击事件 ","date":"2022-07-13","objectID":"/posts/interview/:0:2","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"js 相关 let/const/var 区别，用 const 声明对象时，是否可以改变对象的属性值，为什么 深度优先搜索和广度优先搜索 如何证明 js 对象里存在循环引用 类型判断的方法，typeof 对象的类属性 实例对象是否是 Function ，instanceof Function 结果 promise 执行顺序，事件循环 es5 模拟 class 的实现 localStorage 如何实现过期时间 手机号正则 ","date":"2022-07-13","objectID":"/posts/interview/:0:3","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"工程化相关 介绍 webpack 常用的配置以及功能 webpack 多页面有多个入口时如何配置 source-map 分类，如何配置和调试 webpack 中怎么隔离 css 性能优化方案，代码/打包/资源加载方面 热更新原理 ","date":"2022-07-13","objectID":"/posts/interview/:0:4","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"概念类问题 http/https 区别 介绍 options 请求的意义 MVVM/MVC 的区别，如何实现一个 MVVM 简述 XSS 和 CSRF 的概念，并列举几种安全防范策略 ","date":"2022-07-13","objectID":"/posts/interview/:0:5","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"编程题 编写一个函数，大小写字母取反 const fn = (string) =\u003e { let ans = '' for (let v of string) { ans += v.toLowerCase() === v ? v.toUpperCase() : v.toLowerCase() } return ans } 编写一个函数，输入 int 型，返回整数逆序后的字符串 二维数组扁平化，返回一个去重且是升序的一维数组 ","date":"2022-07-13","objectID":"/posts/interview/:0:6","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"场景题 数据多、加载慢的解决方式 缓存 懒加载 生产环境发布后，发现客户那边并没有更新到最新版，从哪些方面排查？ 时间戳保持最新 强缓存/协商缓存 禁止缓存 axios 需要对所有接口进行增加请求头之类的字段时，怎么处理？ 一个按钮含有异步请求，如何防止多次点击重复提交？ 防抖及其实现，引申节流，描述区别及使用场景 增加禁用属性，loading/disabled a 页面跳转到 b 页面然后重定向到 c 页面，可能会在 b 页面做登录逻辑或者记录数据（相当于一个中转页）， 但是用户可能直接在地址栏里输入 c 页面，怎么防止这个情况？ 路由守卫 导航拦截如何实现 同一个浏览器，不同标签之间数据传递的方法，简单列举 ","date":"2022-07-13","objectID":"/posts/interview/:0:7","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"发散性问题 职业规划 怎么制定技术方案，从哪几个方面考虑 ","date":"2022-07-13","objectID":"/posts/interview/:0:8","tags":["notes"],"title":"面经（2022春）","uri":"/posts/interview/"},{"categories":null,"content":"深度优先搜索 DFS 深度优先搜索（Depth-First-Search）和广度优先搜索（Breadth-First-Search）都是一种用来遍历或者搜索树或图这种数据结构的算法。以树为例，深度优先搜索的过程会从根节点出发，尽可能深地遍历每个子节点，而且每个节点只能访问一次，是一个不断回溯的过程。 实现方法大致如下： 首先将根节点放入栈中 从栈中取出第一个节点，并检验它是否为目标 如果找到目标，则结束搜索并返回结果 否则将它某一个尚未检验过的直接子节点放入栈中 重复步骤 2 如果不存在未检测过的直接子节点 将上一级节点放入栈中 重复步骤 2 重复步骤 4 若栈为空，表示整张图都已检查过并且没有要查找的目标，结束搜索 另外需要我们了解的一种数据结构：栈。 我们可以把盏比喻成一包手帕纸，每张纸巾都是按序一张一张放进去的，使用的时候是一张一张从最上边开始拿出来的。所以栈是一种后进先出（Last In First Out, LIFO）的数据结构。 示例：通过 DFS 实现复制对象的复制 const copyDFS = function(obj) { if (obj === null || typeof obj !== \"object\") { return obj; } const copyObj = Array.isArray(obj) ? [] : {}; for (const key in obj) { copyObj[key] = copyDFS(obj[key]); } return copyObj; } 示例：获取对象的所有键 const obj = { a: 1, b: 2, c: { d: 4, e: 5} } function dfs(obj, keys = []) { Object.entries(obj).forEach(([k, v]) =\u003e { keys.push(k) if (typeof v === 'object') dfs(v, keys) else return }) return keys } // ['a', 'b', 'c', 'd', 'e', 'f'] console.log(dfs(obj)) ","date":"2022-07-07","objectID":"/posts/dfs-bfs/:0:1","tags":["算法"],"title":"算法之 BFS 与 DFS","uri":"/posts/dfs-bfs/"},{"categories":null,"content":"广度优先搜索 BFS 广度优先搜索（Breadth-First-Search）也会沿着树的宽度进行遍历，通常用来解决两种问题： 从节点 A 出发，有前往节点 B 的路径吗？ 从节点 A 出发，前往节点 B 的哪条路径最短？ 举个例子，假如今天的你心血来潮突然想看《假面骑士》，当你打开腾讯视频的时候发现只有会员才能看，真扫兴（胜利的法则变得不太确定）。这时你又不想自费充会员，所以就想找朋友借个用用。于是去挨个去问你的朋友，如果你的朋友里都没有会员，那就必须要找你朋友的朋友，别忘了你的目标是找来一个会员账号。首先，将你的朋友列入一个名单中依次查找，如果你的朋友李白没有会员，其次再将李白的朋友也加入到名单中，所以为了这个目标，你需要在你的朋友、朋友的朋友中查找，这种方式会搜遍你的整个人际关系网络，直到借来一个会员账号（胜利的法则已经决定✌️）或者一个会员都没有为止，这个过程就是广度优先搜索算法。 回到刚才的两个问题： 从节点 A 出发，有前往节点 B 的路径吗？（在你的人际关系网中，有会员吗？） 从节点 A 出发，前往节点 B 的哪条路径最短？（哪个拥有会员的朋友和你的关系最近？） 第一个问题已经在上例中说明；第二个问题就是怎么找到关系最近的朋友。 假设你的朋友是一层关系，朋友的朋友是二层关系。很显然，一层关系优于二层关系，二层关系优于三层关系，以此类推。需要注意的是，一层关系是在二层关系之前加入名单的，这就意味着我们依次对名单按照顺序进行查找出来的结果一定是关系最近的朋友，所以，广度优先搜索不仅查找 A 到 B 的路径，而且找到的是最短路径。 对于 BFS 算法，我们还需要了解另外一个数据结构：队列。 队列的工作原理和现实生活中的队列一样，假设你和朋友一起在排队买咖啡，如果你排在他前面，那就是你先买到咖啡。队列只支持两种操作：入队和出队，是一种先进先出（First In First Out, FIFO）的数据结构， 至此，我们可以使用队列来表示这份朋友名单，因为先加入的朋友（一层关系）将会先出队列并而且先被检查。 实现方法大致如下： 首先将根节点放入队列中 从队列中取出第一个节点，并检查它是否为目标 如果找到目标，则结束搜索并返回结果 否则将它所有尚未检查过的子节点加入队列中 若队列为空，表示整张图都检查过了，即没有查询的目标 重复步骤 2 示例：通过 DFS 实现对象深拷贝： function deepCopy(obj) { const queue = [obj] const newObject = {} while (queue.length \u003e 0) { const currentObj = queue.shift() Object.keys(currentObj).forEach((key) =\u003e { const value = currentObj[key] if (typeof value === 'object' \u0026\u0026 value !== null) { queue.push(value) newObject[key] = Array.isArray(value) ? [] : {} } else { newObject[key] = value } }) } return newObject } const obj = { a: 1, b: 2 } const copy = deepCopy(obj) copy.a = 3 console.log(copy) // {a: 3, b: 2} console.log(copy === obj) // false ","date":"2022-07-07","objectID":"/posts/dfs-bfs/:0:2","tags":["算法"],"title":"算法之 BFS 与 DFS","uri":"/posts/dfs-bfs/"},{"categories":null,"content":"function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; } function SubType() { this.subproperty = false; } // 修改 SubType 的原型，重新指向 SuperType SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; } let instance = new SubType(); console.log(instance.getSuperValue()) // true console.log(instance.getSubValue()) // false 原型链\" 原型链 ","date":"2022-06-10","objectID":"/posts/prototype/:0:0","tags":[""],"title":"原型","uri":"/posts/prototype/"},{"categories":null,"content":" 📌 本篇原文发表于 2018.09.05，正文中出现的有关于时间概念的语句，阅读时请注意切换语境。 👉🏻原文链接 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:0:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"中央处理器/图形处理器/内存/多进程架构 在这个包含 4 篇文章的博客系列中，我们将从高阶架构到具体的渲染细节来深入 Chrome 浏览器内部了解其是怎么运作的。如果你曾经好奇浏览器是怎么把代码转变成一个功能齐备的网站，或者你并不确定为什么一个具体的技术细节能够带来性能提升，那么这个系列正好是为你准备的。 作为系列第一篇，我们将会了解一些核心的计算机术语和 Chrome 浏览器的多进程架构。如果你对 CPU/GPU 和 进程/线程已经很熟悉，可以直接跳到 浏览器架构 章节。 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:1:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"计算机的核心 - CPU 和 GPU 为了理解浏览器所运行的环境，我们需要先了解计算机的一些部件以及它们是做什么的。 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:2:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"中央处理器 CPU 首先是中央处理器（CPU, Central Processing Unit）。CPU 可以被看作是一台计算机的大脑，一个 CPU 内核可以想象成一位办公室工作人员，能够处理一个接一个被安排的多个任务，可以处理一切从数学甚至到艺术领域的难题，而且它知道如何去响应一个用户的指令。以前的大多数 CPU 都是单个芯片，一个内核就相当于是一个 CPU 被嵌入到一个芯片上。在现代的硬件条件下，出现了多核处理器，也赋予了手机、笔记本更强的计算能力。 图 1：四个 CPU 内核就像彼此相邻的办公室职员一样处理多个任务\" 图 1：四个 CPU 内核就像彼此相邻的办公室职员一样处理多个任务 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:2:1","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"图形处理器 GPU 图形处理器是计算机里的另一个部件。和 CPU 不同的是，GPU 更擅长在多核之间处理一些简单的任务。顾名思义，GPU 最初是被开发成处理图形任务的模块，这也是为什么在很多图形计算的背景下，会把“使用 GPU”或“支持 GPU”和快速渲染、流畅的交互体验相关联在一起。近些年来，有了 GPU 加速的计算能力，也使 GPU 独立承载越来越多的计算成为可能。 图2：多个带着扳手🔧️的 GPU 内核，表明它们只能处理有限的任务\" 图2：多个带着扳手🔧️的 GPU 内核，表明它们只能处理有限的任务 当你在手机或电脑上启动一个应用时，是 CPU 和 GPU 在给应用提供运行能力。通常情况下，操作系统提供了一套运行机制供应用程序在 CPU 和 GPU 运行。 图 3: 计算机的三层架构示意图；机械硬件在最底层，操作系统在中间层，应用程序在最上层\" 图 3: 计算机的三层架构示意图；机械硬件在最底层，操作系统在中间层，应用程序在最上层 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:2:2","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"在进程和线程里执行程序 图 4: 进程就像一个鱼缸，线程就像鱼儿🐟️在鱼缸里游泳🏊🏻‍♀️\" 图 4: 进程就像一个鱼缸，线程就像鱼儿🐟️在鱼缸里游泳🏊🏻‍♀️ 在深入了解浏览器架构之前，另一个需要掌握的概念是 进程 和 线程。一个进程可以被看作是一个应用的执行程序，线程不仅是进程的一部分，而且可以执行其所在进程里的任意部分的程序代码。 当启动一个应用时，就等于创建了一个进程。程序可能会创建一个或多个线程来保障其正常工作，当然也可能不会创建。操作系统为进程提供了一个内存管理器，所有的应用状态都被保存在私密的内存空间中，当应用被关闭的时候，该进程也相应消失，同时操作系统也会释放内存。 图 5: 进程使用内存空间存储应用数据\" 图 5: 进程使用内存空间存储应用数据 一个进程可以请求让操作系统去启动另外一个进程以运行不同的任务，如此一来，不同的内存空间也会被分配给新的进程。不同的进程之间可以通过 IPC (进程间通信 Inter Process Communication) 进行通信，许多应用都是使用这种设计方式开发的，以便于当一个工作进程没有响应的时候，该进程可以在不影响其他进程的情况下重新启动。 图 6: 不同的进程之间通过 IPC 进行通信\" 图 6: 不同的进程之间通过 IPC 进行通信 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:3:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"浏览器架构 那么现代浏览器是如何利用进程和线程构建的呢？好吧 =。= 可能是一个进程和很多个不同的线程，也可能是很多不同的进程和一些通过 IPC 通信的线程。 图 7: 进程与线程间的不同浏览器架构\" 图 7: 进程与线程间的不同浏览器架构 需要注意的一个重要信息是，这些不同的架构主要是实现上的细节，构建一个浏览器并没有标准的规范，一个浏览器的实现方式也可能和其他的浏览器完全不同。 在本博客系列中，我们将用下文中的图示来描述 Chrome 浏览器最近更新的的架构。 图中最上层是浏览器进程在统一协调其他进程，它们分别负责应用程序内不同模块的代码执行。对于渲染器进程来说，它会创建多个进程并将其分配给每一个标签页，直到最近，Chrome 会在可能的情况下会给每个标签页分配一个进程；现在，Chrome 正在尝试着给每一个站点分配它自己的进程，包括 iframes（查看 网站隔离）。 图 8: Chrome 的多进程架构示意图。可以看到渲染器进程下是有多个层级的，也表明着 Chrome 在每个标签页中执行着多个渲染器进程\" 图 8: Chrome 的多进程架构示意图。可以看到渲染器进程下是有多个层级的，也表明着 Chrome 在每个标签页中执行着多个渲染器进程 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:4:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"不同的进程及其功能 进程 功能 浏览器进程 控制 Chrome 浏览器应用本身，包括地址栏、书签、返回和前进按钮。同时也处理网页浏览器中那些看不到的、比较特殊的任务，比如网络请求和文件访问等 渲染器进程 控制标签页中一个网页显示的所有内容 插件进程 控制网页中使用的插件，比如 flash GPU 进程 和其他进程相对独立，负责处理图形任务。GPU 进程会被划分为不同的进程，因为它会处理多个应用程序的请求并把它们绘制到同一个界面上。 图 9: 不同的进程负责浏览器界面的不同部分\" 图 9: 不同的进程负责浏览器界面的不同部分 还有很多像扩展和通用的进程。如果你想要查看在 Chrome 中运行了多少进程，可以依次点击右上角的「**···**选项」菜单 →「更多工具」→「任务管理」，之后会打开一个窗口，显示当前运行进程的列表和 CPU 及内存的占用情况。 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:5:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"Chrome 浏览器中多进程的优势 上文中，我们提到 Chrome 使用了多个渲染器进程。举个最简单的例子来讲，你可以想象一下每个标签页都有自己的渲染器进程，让我们假设你已经打开了 3 个标签页，而且每个标签页都由一个独立的渲染器进程负责运行，这时如果其中一个标签页没有响应或是卡死，那你可以关闭这个无响应的页面，同时还能保证其他页面正常运行。但如果所有的标签页都运行在同一个进程上，当有其中一个页面无响应时，那所有的页面也都会死翘翘，着实令人难过。🥲 图 10: 每个标签页运行多个进程\" 图 10: 每个标签页运行多个进程 将浏览器的工作分离成多个进程的另一个好处是安全和沙盒化。由于操作系统提供了一种限制进程的方法，浏览器可以对某些进程进行沙盒化处理，使其与某些功能隔离起来。例如，浏览器限制了任意用户的输入进程对访问文件的权限，就像渲染器进程一样。 由于进程都有自己私有的内存空间，它们通常包含了一些通用基础架构的副本（如 V8 ， Chrome 的 JS 引擎）。这意味着会有更多的内存占用，因为它们不能像在同一进程中的线程那样共享。为了节省内存，Chrome 限制了它可以启动的进程数量，限制的进程数取决于设备的内存大小和 CPU 功率，当到达了限制数的上限时，它就会开始将同一站点的多个标签页运行在一个进程上。 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:6:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"节省更多内存 - Chrome 中的服务化 浏览器进程的实现方式是大致相同的。Chrome 正在改变它的架构，将浏览器程序的每个部分作为服务运行，从而可以轻松地将浏览器的各个模块拆分为不同的进程或者聚合为一个进程。 通常情况下，当 Chrome 运行在一个配置强悍的硬件上时， 它可能会将每个服务分离成不同的进程，以获取更好的稳定性，但是如果是一台配置有限的设备上，Chrome 会为了节省内存占用将服务合并为一个进程。这与之前安卓平台的实现方式大同小异，都是通过合并进程来换来更少的内存占用。 图 11: Chrome 将不同的服务转化为多个进程和一个浏览器进程\" 图 11: Chrome 将不同的服务转化为多个进程和一个浏览器进程 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:7:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"单个 frame 渲染器进程 - 网站隔离 网站隔离 是 Chrome 最近介绍的一项新功能，该功能可以为每一个跨域的 iframe 运行一个单独的渲染器进程。我们已经阐述过单个标签页对应单个渲染器进程的模式，这种模式允许跨域的 iframe 运行在一个单独的渲染器进程里，同时和其他网站共享内存空间。这也使得在同一个渲染器进程里运行 a.com 和 b.com 看起来是没什么问题的。同源策略 是浏览器里核心的安全模型，它保证了一个网站不能在没有获取另一个网站的允许下访问该网站的数据。绕过这个策略是很多攻击网站安全的主要目标，而进程隔离是隔离网站最有效的方式，有了 幽灵漏洞 ，可以更明显地意识到，我们需要使用进程来隔离网站。自从 Chrome 67 之后，默认情况下隔离功能是开启的，这样一来，每个跨域的网站都会有一个单独的渲染器进程。 图 12: 网站隔离，一个网页中有多个渲染器进程指向 iframe\" 图 12: 网站隔离，一个网页中有多个渲染器进程指向 iframe 支持网站隔离功能是开发者多年以来努力的成果，网站隔离并不像合并多个不同的渲染器进程那样简单，它从根本上改变了 iframes 之间相互通信的方式。在不同进程中运行 iframe 的页面上打开 devtools，意味着 devtools 不得不执行一些幕后工作，才能使其看起来像无缝衔接。甚至是一个简单的 Ctrl+F 查找功能都要横跨数个不同的渲染器进程进行搜索。现在你能明白为什么浏览器开发工程师们说网站隔离的发布可以看作是一个里程碑的实现了吧！（哈哈哈真不容易🤓）。 ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:8:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":"总结 本篇文章中，我们已经介绍了从高阶视角来看待浏览器架构和多进程架构的优势，还涉及到了 Chrome 中与多进程架构有深深关联的服务化和网站隔离。在下一篇文章中，我们将开始深入了解使网站呈现出来时，进程和线程之间都发生了什么事情。 下一篇：导航栏里发生了什么事情？ ","date":"2022-05-18","objectID":"/posts/inside-look-at-modern-web-browser-1/:9:0","tags":["翻译"],"title":"深入了解现代网络浏览器（1/4）【译】","uri":"/posts/inside-look-at-modern-web-browser-1/"},{"categories":null,"content":" A CHAMPAGNE SUPERNOVA IN THE SKY :D ","date":"2019-04-02","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]